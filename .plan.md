# COMPREHENSIVE IMPLEMENTATION PLAN
## Integrating UKMARS Mazerunner-Core Movement Logic into Jurababa PID_VM Branch

**Date:** 2026-01-03
**Branch:** PID_VM
**Target:** Clean integration of mazerunner-core concepts while preserving existing architecture

---

## EXECUTIVE SUMMARY

The PID_VM branch has already made significant progress toward a clean motion control architecture:
- **Deleted old files**: Motion.h, Profile.h, Odometry.h (these had trapezoidal profiling but poor structure)
- **Created new Robot class**: Clean mode-based architecture with PID control
- **Enhanced PIDController**: Robust implementation with filtering, deadband, integral limiting
- **Refactored Drivetrain**: Type-safe API with basic feedforward (Kv + Ks)

**What's missing from mazerunner-core concepts:**
1. **Trapezoidal motion profiles** - Currently uses simple linear ramping
2. **Acceleration feedforward** - Only has velocity feedforward (Kv) and static friction (Ks)
3. **Better motion profiling** - Current deceleration logic is basic

**The good news:** The architecture is already well-structured. We don't need to delete Robot.cpp entirely - we should enhance it.

---

## SECTION 1: CURRENT STATE ANALYSIS

### 1.1 Current Architecture (PID_VM Branch)

```
Layer 1: High-Level Control (Navigation/Planning)
    â”œâ”€â”€ API (Platform/Pico/API.h)
    â””â”€â”€ InternalMouse (Maze/InternalMouse.h)

Layer 2: Motion Control (Robot Brain)
    â””â”€â”€ Robot (Platform/Pico/Robot/Robot.h) â­ MAIN CLASS
        â”œâ”€â”€ Mode-based state machine
        â”œâ”€â”€ Yaw PID controller (rotation control)
        â””â”€â”€ Wheel velocity PID controllers (low-level control)

Layer 3: Hardware Abstraction
    â”œâ”€â”€ Drivetrain (Platform/Pico/Robot/Drivetrain.h)
    â”‚   â”œâ”€â”€ Feedforward calculation (Kv, Ks)
    â”‚   â””â”€â”€ Velocity estimation
    â””â”€â”€ Sensors (Platform/Pico/Robot/Sensors.h)
        â”œâ”€â”€ IMU wrapper
        â””â”€â”€ ToF wrapper

Layer 4: Hardware Drivers
    â”œâ”€â”€ Motor (PWM control)
    â”œâ”€â”€ Encoder (PIO-based quadrature)
    â”œâ”€â”€ IMU (BNO085)
    â””â”€â”€ ToF (VL53L0X)
```

### 1.2 Current Robot.cpp Implementation

**File:** `/home/user/Jurababa_2025-2026/src/Platform/Pico/Robot/Robot.cpp`

**Strengths:**
- Clean mode-based architecture (Idle, DriveStraight, DriveDistance, TurnInPlace, ArcTurn)
- Three PID controllers: yawPID, leftWheelPID, rightWheelPID
- Dual-layer control: high-level (yaw) + low-level (wheel velocity)
- Feedforward + feedback control for wheels
- Slew rate limiting for duty cycles
- Yaw profiling with maximum angular velocity
- Type-safe WheelSide enum instead of strings

**Weaknesses:**
- **No trapezoidal velocity profiling** - uses simple rampToward() with constant acceleration
- **Poor deceleration control** - calculateTargetVelocityForDistance() has basic physics but no proper profiling
- **No acceleration feedforward** - only velocity (Kv) and static friction (Ks) terms
- **Hard-coded constants** - many magic numbers instead of using profiles
- **Basic motion completion** - simple position + velocity thresholds

### 1.3 Current PIDController Implementation

**File:** `/home/user/Jurababa_2025-2026/Include/Common/PIDController.h`

**Features:**
- Proportional, Integral, Derivative terms
- Integral windup protection with configurable limits
- Derivative filtering (low-pass filter)
- Error deadband
- Output limiting
- First-step derivative spike protection

**Analysis:** This is a well-implemented PID controller that can be used as-is or easily converted to PD (by setting Ki=0).

### 1.4 Current Drivetrain Implementation

**File:** `/home/user/Jurababa_2025-2026/src/Platform/Pico/Robot/Drivetrain.cpp`

**Current Feedforward:**
```cpp
float Drivetrain::getFeedforward(WheelSide side, float wheel_speed_mm_per_second)
{
    // Only Kv (velocity) and Ks (static friction) terms
    if (forward) {
        return kv * wheel_speed + ks;  // No Ka (acceleration) term!
    }
}
```

**Missing:** Acceleration feedforward (Ka term) needed for mazerunner-core style control.

---

## SECTION 2: WHAT WE ALREADY HAVE VS WHAT'S MISSING

| Mazerunner Feature | Current Status | Location |
|-------------------|----------------|----------|
| Dual PD Controllers | âœ… HAVE (3 PIDs, can configure as PD) | Robot.cpp, PIDController.h |
| Velocity Feedforward (Kv) | âœ… HAVE | Drivetrain.cpp (getFeedforward) |
| Static Friction (Ks) | âœ… HAVE | Drivetrain.cpp (getFeedforward) |
| Acceleration FF (Ka) | âŒ MISSING | Need to add |
| Trapezoidal Profiles | âŒ MISSING | Need to create MotionProfile class |
| Layered Architecture | âœ… HAVE | Robot â†’ Drivetrain â†’ Motor/Encoder |

---

## SECTION 3: PROPOSED ARCHITECTURE

### 3.1 Philosophy: Enhance, Don't Replace

**DECISION: Keep Robot.cpp, add MotionProfile class**

Rationale:
1. Current Robot.cpp has good structure (mode-based, clean separation)
2. Existing PIDController is well-implemented
3. Drivetrain abstraction is clean
4. Just need to add motion profiling and better feedforward

### 3.2 New Class Structure

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Robot (Enhanced)                                             â”‚
â”‚ - Manages motion state machine                               â”‚
â”‚ - Uses MotionProfile for velocity/accel generation           â”‚
â”‚ - Runs PD controllers for yaw and wheel velocity             â”‚
â”‚ - Calls Drivetrain with full feedforward (Kv+Ks+Ka)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â”œâ”€â”€ Uses
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MotionProfile (NEW CLASS)                                    â”‚
â”‚ - Generates trapezoidal velocity profiles                    â”‚
â”‚ - Tracks profile state (Accel, Cruise, Decel, Done)         â”‚
â”‚ - Outputs: position, velocity, acceleration setpoints        â”‚
â”‚ - Handles both linear and rotational motion                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                          â”œâ”€â”€ Used by Robot
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Drivetrain (Enhanced)                                        â”‚
â”‚ - Add Ka (acceleration feedforward) term                     â”‚
â”‚ - getFeedforward(side, velocity, acceleration)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.3 File Organization Plan

**New Files to Create:**
```
/home/user/Jurababa_2025-2026/Include/Common/MotionProfile.h
/home/user/Jurababa_2025-2026/src/Common/MotionProfile.cpp
```

**Files to Modify:**
```
/home/user/Jurababa_2025-2026/Include/Platform/Pico/Robot/Robot.h
/home/user/Jurababa_2025-2026/src/Platform/Pico/Robot/Robot.cpp
/home/user/Jurababa_2025-2026/Include/Platform/Pico/Robot/Drivetrain.h
/home/user/Jurababa_2025-2026/src/Platform/Pico/Robot/Drivetrain.cpp
/home/user/Jurababa_2025-2026/Include/Platform/Pico/Config.h
/home/user/Jurababa_2025-2026/CMakeLists.txt
```

**Files to Delete:**
```
NONE - We keep Robot.cpp and enhance it!
```

---

## SECTION 4: DETAILED IMPLEMENTATION PLAN

### Phase 1: Create MotionProfile Class

**File:** `/home/user/Jurababa_2025-2026/Include/Common/MotionProfile.h`

**Design:**
```cpp
class MotionProfile
{
public:
    enum class State {
        Idle,
        Accelerating,
        Cruising,
        Decelerating,
        Finished
    };

    // Initialize profile
    void start(float targetDistance, float maxVelocity,
               float acceleration, float initialPosition);

    // Update profile based on current position
    void update(float currentPosition, float dt);

    // Get current setpoints
    float getTargetVelocity() const;
    float getTargetAcceleration() const;
    float getRemainingDistance() const;

    // Status
    bool isFinished() const;
    State getState() const;

    void reset();

private:
    State state_;
    float targetDistance_;
    float maxVelocity_;
    float acceleration_;
    float initialPosition_;

    // Runtime state
    float currentVelocity_;
    float currentAcceleration_;

    // Pre-calculated profile parameters
    float accelDistance_;      // Distance during acceleration phase
    float decelDistance_;      // Distance during deceleration phase
    float cruiseDistance_;     // Distance at constant velocity
    float cruiseVelocity_;     // Actual cruise velocity (may be < maxVelocity)
};
```

**Key Features:**
1. **Trapezoidal profile generation** - calculates accel/cruise/decel phases
2. **Position-based state tracking** - transitions based on distance traveled
3. **Time-based updates** - smooth velocity/acceleration output
4. **Handles short moves** - automatically adjusts when can't reach maxVelocity

### Phase 2: Enhance Drivetrain with Acceleration Feedforward

**Changes to `/home/user/Jurababa_2025-2026/Include/Platform/Pico/Robot/Drivetrain.h`:**

1. **Add acceleration parameter to getFeedforward:**
```cpp
// Current signature:
float getFeedforward(WheelSide side, float wheel_speed_mm_per_second);

// New signature:
float getFeedforward(WheelSide side, float wheel_speed_mm_per_second,
                    float wheel_accel_mm_per_second2 = 0.0f);
```

2. **Implement Ka term in Drivetrain.cpp:**
```cpp
float Drivetrain::getFeedforward(WheelSide side, float velocity, float accel)
{
    if (std::fabs(velocity) < DRIVETRAIN_FF_DEADZONE_MMPS)
        return 0.0f;

    bool is_left = (side == WheelSide::LEFT);

    float kv, ks, ka;
    if (velocity > 0.0f) {
        kv = is_left ? FORWARD_KVL : FORWARD_KVR;
        ks = is_left ? FORWARD_KSL : FORWARD_KSR;
        ka = is_left ? FORWARD_KAL : FORWARD_KAR;
        return kv * velocity + ks + ka * accel;
    } else {
        kv = is_left ? REVERSE_KVL : REVERSE_KVR;
        ks = is_left ? REVERSE_KSL : REVERSE_KSR;
        ka = is_left ? REVERSE_KAL : REVERSE_KAR;
        return kv * velocity - ks + ka * accel;
    }
}
```

**Add to Config.h:**
```cpp
// Acceleration feedforward constants (start with 0, tune empirically)
#define FORWARD_KAL 0.0f  // Left motor acceleration gain
#define FORWARD_KAR 0.0f  // Right motor acceleration gain
#define REVERSE_KAL 0.0f  // Left motor reverse acceleration gain
#define REVERSE_KAR 0.0f  // Right motor reverse acceleration gain
```

### Phase 3: Integrate MotionProfile into Robot

**Changes to `/home/user/Jurababa_2025-2026/Include/Platform/Pico/Robot/Robot.h`:**

```cpp
#include "Common/MotionProfile.h"

class Robot {
private:
    // Add motion profiles
    MotionProfile forwardProfile_;   // For linear motion
    MotionProfile rotationProfile_;  // For rotational motion
    float currentAcceleration_;      // For feedforward

    // ... rest of existing members
};
```

**Major changes to Robot.cpp:**

1. **Update driveDistanceMM():**
```cpp
void Robot::driveDistanceMM(float distanceMM, float forwardMMps)
{
    mode = Mode::DriveDistance;

    // Start motion profile
    float currentPos = (drivetrain->getMotorDistanceMM(WheelSide::LEFT) +
                       drivetrain->getMotorDistanceMM(WheelSide::RIGHT)) / 2.0f;
    forwardProfile_.start(distanceMM, forwardMMps, ROBOT_BASE_ACCEL_MMPS2, currentPos);

    targetYawDeg = RobotUtils::snapTo45Degrees(sensors->getYaw());

    yawPID.reset();
    leftWheelPID.reset();
    rightWheelPID.reset();

    motionDone = false;
}
```

2. **Rewrite handleDriveDistanceMode():**
```cpp
void Robot::handleDriveDistanceMode(float dt)
{
    // Update motion profile
    float currentPos = (drivetrain->getMotorDistanceMM(WheelSide::LEFT) +
                       drivetrain->getMotorDistanceMM(WheelSide::RIGHT)) / 2.0f;
    forwardProfile_.update(currentPos, dt);

    // Check if finished
    if (forwardProfile_.isFinished()) {
        stop();
        motionDone = true;
        return;
    }

    // Get profiled velocity and acceleration
    float vBase = forwardProfile_.getTargetVelocity();
    currentAcceleration_ = forwardProfile_.getTargetAcceleration();

    // Execute motion with profiled velocity
    commandBaseAndYaw(vBase, dt);
    motionDone = false;
}
```

3. **Update runWheelVelocityControl():**
```cpp
void Robot::runWheelVelocityControl(float dt)
{
    float vLeft  = drivetrain->getMotorVelocityMMps(WheelSide::LEFT);
    float vRight = drivetrain->getMotorVelocityMMps(WheelSide::RIGHT);

    // Calculate feedforward with acceleration (NEW!)
    float accelLeft = currentAcceleration_;
    float accelRight = currentAcceleration_;

    float ffLeft  = drivetrain->getFeedforward(WheelSide::LEFT, targetLeftMMps, accelLeft);
    float ffRight = drivetrain->getFeedforward(WheelSide::RIGHT, targetRightMMps, accelRight);

    // PID feedback
    float errorLeft  = targetLeftMMps - vLeft;
    float errorRight = targetRightMMps - vRight;
    float fbLeft  = leftWheelPID.calculateOutput(errorLeft, dt);
    float fbRight = rightWheelPID.calculateOutput(errorRight, dt);

    // Combine FF + FB
    float leftDuty  = ffLeft + fbLeft;
    float rightDuty = ffRight + fbRight;

    // Clamp and slew
    leftDuty  = RobotUtils::clampAbs(leftDuty, ROBOT_MAX_DUTY);
    rightDuty = RobotUtils::clampAbs(rightDuty, ROBOT_MAX_DUTY);
    leftDuty  = applySlew(leftDuty, prevLeftDuty, dt);
    rightDuty = applySlew(rightDuty, prevRightDuty, dt);

    drivetrain->setDuty(leftDuty, rightDuty);
}
```

### Phase 4: Add Configuration Constants

**File:** `/home/user/Jurababa_2025-2026/Include/Platform/Pico/Config.h`

```cpp
// ================= Motion Profile Constants ================= //
#define PROFILE_MAX_FORWARD_VELOCITY_MMPS  500.0f  // Max linear velocity
#define PROFILE_MAX_FORWARD_ACCEL_MMPS2    1500.0f // Linear acceleration
#define PROFILE_MAX_ANGULAR_VELOCITY_DEGPS 360.0f  // Max angular velocity
#define PROFILE_MAX_ANGULAR_ACCEL_DEGPS2   720.0f  // Angular acceleration

// Completion tolerances
#define PROFILE_POSITION_TOLERANCE_MM  2.0f        // Position error threshold
#define PROFILE_VELOCITY_TOLERANCE_MMPS 30.0f      // Velocity threshold for "stopped"
```

### Phase 5: Update CMakeLists.txt

```cmake
target_sources(${PROJECT_NAME} PRIVATE
    src/Common/MotionProfile.cpp
    # ... existing sources
)
```

---

## SECTION 5: IMPLEMENTATION STEPS (EXECUTION ORDER)

### Step 1: Create MotionProfile Class (1-2 hours)
1. Create `Include/Common/MotionProfile.h`
2. Create `src/Common/MotionProfile.cpp`
3. Implement trapezoidal profile algorithm
4. Add to CMakeLists.txt

### Step 2: Add Acceleration Feedforward to Drivetrain (30 min)
1. Modify `Drivetrain::getFeedforward()` signature
2. Add Ka term to calculation
3. Add Ka constants to Config.h (initialize to 0.0f)

### Step 3: Integrate MotionProfile into Robot (2-3 hours)
1. Add MotionProfile members to Robot.h
2. Modify `driveDistanceMM()` to initialize profile
3. Rewrite `handleDriveDistanceMode()` to use profile
4. Update `runWheelVelocityControl()` to use acceleration

### Step 4: Add Rotation Profiling (1 hour)
1. Modify `turnToYawDeg()` to use rotationProfile_
2. Update `handleTurnInPlaceMode()` with profiled motion

### Step 5: Clean Up Deprecated Code (30 min)
1. Remove `calculateTargetVelocityForDistance()`
2. Simplify or remove `rampToward()`
3. Update documentation

### Step 6: Testing and Tuning (Variable)
1. Test basic motion (single cell, turn, multiple cells)
2. Tune Ka values (start at 0.0f, increase gradually)
3. Verify smooth profiles
4. Adjust PID gains if needed

---

## SECTION 6: WHAT TO KEEP VS REPLACE

### âœ… Keep (Good Existing Code)

- **PIDController class** - Well-implemented, use as-is
- **Robot class structure** - Mode-based architecture is clean
- **Drivetrain abstraction** - Just add Ka term
- **RobotUtils** - Good utility functions
- **Hardware layer** - Motor, Encoder, Sensors, IMU, ToF
- **Configuration system** - Config.h is well-organized
- **Multicore architecture** - Core0/Core1 split

### ğŸ”„ Replace/Modify

- **Robot::handleDriveDistanceMode()** - Replace ramping with profiling
- **Robot::runWheelVelocityControl()** - Add acceleration feedforward
- **Drivetrain::getFeedforward()** - Add acceleration parameter
- **Robot::commandBaseAndYaw()** - Simplify with profiling

### âŒ Delete

- **calculateTargetVelocityForDistance()** - Replaced by MotionProfile
- **rampToward()** - May be obsolete if profile handles ramping
- **Manual deceleration logic** - Profile handles this

### âš ï¸ Do NOT Delete Robot.cpp!

Robot.cpp should be **ENHANCED, not deleted** because:
1. Good mode-based state machine architecture
2. Already uses PID controllers properly
3. Clean separation of concerns
4. Just needs better motion profiling

---

## SECTION 7: BENEFITS OF THIS APPROACH

1. **Reuses existing PIDController** - No need to rewrite PID logic
2. **Maintains existing architecture** - Robot â†’ Drivetrain â†’ Motor
3. **Incremental integration** - Each phase testable independently
4. **Low risk** - Doesn't break existing functionality
5. **Backward compatible** - API stays the same
6. **Incorporates mazerunner-core patterns**:
   - Trapezoidal velocity profiles
   - Three-term feedforward (Kv + Ks + Ka)
   - Dual-layer control (high-level + low-level)

---

## SECTION 8: ESTIMATED TIMELINE

- Phase 1 (MotionProfile): **2 hours**
- Phase 2 (Drivetrain Ka): **30 minutes**
- Phase 3 (Robot integration): **3 hours**
- Phase 4 (Rotation profiling): **1 hour**
- Phase 5 (Cleanup): **30 minutes**
- Phase 6 (Testing/tuning): **4-8 hours**

**Total: 11-15 hours** for complete integration and tuning

---

## SECTION 9: CRITICAL FILES

1. **`Include/Common/MotionProfile.h`** (NEW) - Core profiling logic
2. **`src/Platform/Pico/Robot/Robot.cpp`** (MODIFY) - Main integration point
3. **`src/Platform/Pico/Robot/Drivetrain.cpp`** (MODIFY) - Add Ka feedforward
4. **`Include/Platform/Pico/Config.h`** (MODIFY) - Add constants
5. **`Include/Platform/Pico/Robot/Robot.h`** (MODIFY) - Add MotionProfile members

---

## CONCLUSION

The PID_VM branch already has excellent architecture. We just need to add:
1. **MotionProfile class** for trapezoidal velocity generation
2. **Ka acceleration feedforward** in Drivetrain
3. **Integration** in Robot to use profiles

This is a clean, incremental enhancement that preserves all the good work already done while incorporating the best concepts from mazerunner-core.

**Recommendation: Proceed with implementation starting with Phase 1 (MotionProfile class).**
