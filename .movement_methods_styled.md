# Movement Methods - Styled to Match Existing Code

## Code Style Analysis from Robot.cpp

**Your patterns:**
1. Simple method names with units (driveDistanceMM, turnToYawDeg)
2. Methods start by setting state/mode
3. Clear target value initialization
4. Reset controllers
5. Set completion flags
6. Big header comments with `// ====...====`
7. Step-by-step inline comments
8. Early returns for completion
9. Type-safe enums (WheelSide::LEFT/RIGHT)
10. Periodic logging with counter modulo

---

## New Movement Methods (Your Style)

```cpp
// ============================================================
// Basic Motion Commands
// ============================================================

void Robot::moveDistance(float distanceMM, float maxVelocityMMps, float accelerationMMps2)
{
    state = MotionState::MovingForward;

    // Get current position baseline
    float currentPos = (drivetrain->getMotorDistanceMM(WheelSide::LEFT) +
                       drivetrain->getMotorDistanceMM(WheelSide::RIGHT)) / 2.0f;

    // Start forward motion profile
    forwardProfile.start(distanceMM, maxVelocityMMps, accelerationMMps2, currentPos);
    rotationProfile.reset();

    // Snap to nearest 45-degree heading for maze alignment
    targetYawDeg = RobotUtils::snapTo45Degrees(sensors->getYaw());

    // Reset controllers for clean start
    forwardController.reset();
    rotationController.reset();
    forwardError     = 0.0f;
    rotationError    = 0.0f;
    prevForwardError = 0.0f;
    prevRotationError = 0.0f;

    // Initialize velocity targets
    targetForwardVelocityMMps   = 0.0f;  // Will be updated by profile
    targetAngularVelocityDegps  = 0.0f;  // Maintain heading
    targetForwardAccelerationMMps2 = 0.0f;

    motionDone = false;
}

void Robot::turnInPlace(float degrees, float maxVelocityDegps, float accelerationDegps2)
{
    state = MotionState::TurningInPlace;

    // Get current angle baseline
    float currentAngle = sensors->getYaw();

    // Start rotation profile
    rotationProfile.start(degrees, maxVelocityDegps, accelerationDegps2, currentAngle);
    forwardProfile.reset();

    // Reset controllers for clean start
    forwardController.reset();
    rotationController.reset();
    forwardError     = 0.0f;
    rotationError    = 0.0f;
    prevForwardError = 0.0f;
    prevRotationError = 0.0f;

    // Initialize velocity targets
    targetForwardVelocityMMps   = 0.0f;  // No forward motion
    targetAngularVelocityDegps  = 0.0f;  // Will be updated by profile
    targetForwardAccelerationMMps2 = 0.0f;

    motionDone = false;
}

void Robot::stopAtCenter()
{
    state = MotionState::Stopping;

    // Reset profiles to stop motion
    forwardProfile.reset();
    rotationProfile.reset();

    // Set zero velocity targets (controllers remain active for position hold)
    targetForwardVelocityMMps   = 0.0f;
    targetAngularVelocityDegps  = 0.0f;
    targetForwardAccelerationMMps2 = 0.0f;

    // Keep errors intact for smooth settling
    // Controllers will naturally decay errors as robot stops
}

void Robot::stop()
{
    state = MotionState::Idle;

    // Reset profiles
    forwardProfile.reset();
    rotationProfile.reset();

    // Reset all targets
    targetForwardVelocityMMps   = 0.0f;
    targetAngularVelocityDegps  = 0.0f;
    targetForwardAccelerationMMps2 = 0.0f;

    // Reset controllers and errors for full stop
    forwardController.reset();
    rotationController.reset();
    forwardError     = 0.0f;
    rotationError    = 0.0f;
    prevForwardError = 0.0f;
    prevRotationError = 0.0f;

    // Stop motors immediately
    prevLeftDuty  = 0.0f;
    prevRightDuty = 0.0f;
    drivetrain->stop();

    motionDone = true;
}

// ============================================================
// Cell Navigation (Convenience Wrappers)
// ============================================================

void Robot::moveToNextCell()
{
    moveDistance(CELL_SIZE_MM, ROBOT_MAX_SEARCH_SPEED_MMPS, ROBOT_BASE_ACCEL_MMPS2);
}

void Robot::turnLeft90()
{
    turnInPlace(-90.0f, ROBOT_MAX_TURN_SPEED_DEGPS, ROBOT_BASE_ANGULAR_ACCEL_DEGPS2);
}

void Robot::turnRight90()
{
    turnInPlace(90.0f, ROBOT_MAX_TURN_SPEED_DEGPS, ROBOT_BASE_ANGULAR_ACCEL_DEGPS2);
}

void Robot::turnAround()
{
    // Alternate direction like mazerunner-core to reduce drift
    static bool turnRight = true;
    float angle = turnRight ? 180.0f : -180.0f;
    turnRight = !turnRight;

    turnInPlace(angle, ROBOT_MAX_TURN_SPEED_DEGPS, ROBOT_BASE_ANGULAR_ACCEL_DEGPS2);
}

// ============================================================
// Advanced Motion
// ============================================================

void Robot::smoothTurn(float degrees, float radiusMM)
{
    state = MotionState::SmoothTurning;

    // Calculate arc length from turn angle and radius
    float arcLengthMM = std::fabs(degrees) * (M_PI / 180.0f) * radiusMM;

    // Get current baselines
    float currentPos   = (drivetrain->getMotorDistanceMM(WheelSide::LEFT) +
                         drivetrain->getMotorDistanceMM(WheelSide::RIGHT)) / 2.0f;
    float currentAngle = sensors->getYaw();

    // Start both profiles simultaneously for coordinated motion
    forwardProfile.start(arcLengthMM, ROBOT_MAX_SMOOTH_TURN_SPEED_MMPS,
                        ROBOT_BASE_ACCEL_MMPS2, currentPos);
    rotationProfile.start(degrees, ROBOT_MAX_TURN_SPEED_DEGPS,
                         ROBOT_BASE_ANGULAR_ACCEL_DEGPS2, currentAngle);

    // Reset controllers for clean start
    forwardController.reset();
    rotationController.reset();
    forwardError     = 0.0f;
    rotationError    = 0.0f;
    prevForwardError = 0.0f;
    prevRotationError = 0.0f;

    // Initialize velocity targets (will be updated by profiles)
    targetForwardVelocityMMps   = 0.0f;
    targetAngularVelocityDegps  = 0.0f;
    targetForwardAccelerationMMps2 = 0.0f;

    motionDone = false;

    LOG_DEBUG("SmoothTurn | Angle: " + std::to_string(degrees) +
              " deg | Radius: " + std::to_string(radiusMM) +
              " mm | Arc: " + std::to_string(arcLengthMM) + " mm");
}

void Robot::backToWall(float maxDistanceMM)
{
    state = MotionState::MovingForward;

    // Move backward slowly until wall detected or max distance reached
    float currentPos = (drivetrain->getMotorDistanceMM(WheelSide::LEFT) +
                       drivetrain->getMotorDistanceMM(WheelSide::RIGHT)) / 2.0f;

    // Negative distance for reverse motion
    forwardProfile.start(-maxDistanceMM, ROBOT_BACKUP_SPEED_MMPS,
                        ROBOT_BASE_ACCEL_MMPS2, currentPos);
    rotationProfile.reset();

    // Snap to current heading
    targetYawDeg = RobotUtils::snapTo45Degrees(sensors->getYaw());

    // Reset controllers
    forwardController.reset();
    rotationController.reset();
    forwardError     = 0.0f;
    rotationError    = 0.0f;
    prevForwardError = 0.0f;
    prevRotationError = 0.0f;

    // Initialize velocity targets
    targetForwardVelocityMMps   = 0.0f;
    targetAngularVelocityDegps  = 0.0f;
    targetForwardAccelerationMMps2 = 0.0f;

    motionDone = false;

    LOG_DEBUG("BackToWall | Max distance: " + std::to_string(maxDistanceMM) + " mm");
}

void Robot::centerWithWalls()
{
    // Use ToF sensors to adjust lateral position for centering
    // This is a position adjustment, not continuous motion

    float leftDistMM  = sensors->getLeftDistanceMM();
    float rightDistMM = sensors->getRightDistanceMM();

    // Calculate centering offset
    float lateralErrorMM = (rightDistMM - leftDistMM) / 2.0f;

    // Only center if walls are detected on both sides
    if (leftDistMM > TOF_MAX_RANGE_MM || rightDistMM > TOF_MAX_RANGE_MM)
    {
        LOG_DEBUG("CenterWithWalls | Cannot center - wall(s) not detected");
        return;
    }

    // Small lateral adjustment using rotation controller as steering correction
    // This adds to rotation error during next motion command
    rotationError += lateralErrorMM * CENTERING_CORRECTION_GAIN;

    LOG_DEBUG("CenterWithWalls | Left: " + std::to_string(leftDistMM) +
              " mm | Right: " + std::to_string(rightDistMM) +
              " mm | Offset: " + std::to_string(lateralErrorMM) + " mm");
}

// ============================================================
// Status Queries
// ============================================================

bool Robot::isMotionComplete() const
{
    return motionDone;
}

float Robot::getRemainingDistance() const
{
    return forwardProfile.getRemainingDistance();
}

float Robot::getRemainingAngle() const
{
    return rotationProfile.getRemainingDistance();  // Same method for angular distance
}

// ============================================================
// Control Loop (called at 100Hz from Core1)
// ============================================================

void Robot::updateControl(float dt)
{
    if (dt <= 0.0f)
        return;

    // Update sensor measurements
    drivetrain->updateVelocities(dt);
    sensors->update(dt);

    // Periodic logging
    static int logCounter = 0;
    if ((logCounter++ % 100) == 0)  // Every 1 second at 100Hz
    {
        LOG_DEBUG("Robot | State: " + getStateName() +
                  " | ForwardVel: " + std::to_string(targetForwardVelocityMMps) +
                  " mm/s | AngularVel: " + std::to_string(targetAngularVelocityDegps) +
                  " deg/s | Yaw: " + std::to_string(sensors->getYaw()) + " deg");
    }

    // Update motion profiles based on current state
    switch (state)
    {
        case MotionState::MovingForward:
            updateForwardProfile(dt);
            checkForwardCompletion();
            break;

        case MotionState::TurningInPlace:
            updateRotationProfile(dt);
            checkRotationCompletion();
            break;

        case MotionState::SmoothTurning:
            updateForwardProfile(dt);
            updateRotationProfile(dt);
            checkSmoothTurnCompletion();
            break;

        case MotionState::Stopping:
            // No profile updates - just let controllers settle
            checkStoppingCompletion();
            break;

        case MotionState::Idle:
            // Do nothing
            return;
    }

    // Run position control loop (all states except Idle)
    if (state != MotionState::Idle)
    {
        runPositionControl(dt);
    }
}

// ============================================================
// Profile Update Methods
// ============================================================

void Robot::updateForwardProfile(float dt)
{
    // Get current position from encoders
    float currentPos = (drivetrain->getMotorDistanceMM(WheelSide::LEFT) +
                       drivetrain->getMotorDistanceMM(WheelSide::RIGHT)) / 2.0f;

    // Update profile
    forwardProfile.update(currentPos, dt);

    // Update target velocity and acceleration for control loop
    targetForwardVelocityMMps      = forwardProfile.getTargetVelocity();
    targetForwardAccelerationMMps2 = forwardProfile.getTargetAcceleration();
}

void Robot::updateRotationProfile(float dt)
{
    // Get current angle from IMU
    float currentAngle = sensors->getYaw();

    // Update profile
    rotationProfile.update(currentAngle, dt);

    // Update target angular velocity
    targetAngularVelocityDegps = rotationProfile.getTargetVelocity();
}

// ============================================================
// Completion Check Methods
// ============================================================

void Robot::checkForwardCompletion()
{
    if (forwardProfile.isFinished())
    {
        // Check if we need to stop due to wall detection (for backToWall)
        if (state == MotionState::MovingForward && targetForwardVelocityMMps < 0.0f)
        {
            // Backing up - check for wall contact
            float frontDistMM = sensors->getFrontDistanceMM();
            if (frontDistMM < WALL_CONTACT_THRESHOLD_MM)
            {
                stop();
                motionDone = true;

                // Reset odometry - we know we're BACK_WALL_TO_CENTER mm from center
                drivetrain->resetPosition();
                LOG_DEBUG("BackToWall | Wall contact detected, position reset");
                return;
            }
        }

        // Normal completion
        stopAtCenter();
        motionDone = true;
    }
}

void Robot::checkRotationCompletion()
{
    if (rotationProfile.isFinished())
    {
        // Additional stability check - verify angular velocity is low
        float angularVel = sensors->getAngularVelocityDegps();

        if (std::fabs(angularVel) <= ROBOT_TURN_STABILITY_DEGPS)
        {
            stopAtCenter();
            motionDone = true;
        }
    }
}

void Robot::checkSmoothTurnCompletion()
{
    // Smooth turn complete when BOTH profiles finish
    if (forwardProfile.isFinished() && rotationProfile.isFinished())
    {
        stopAtCenter();
        motionDone = true;
    }
}

void Robot::checkStoppingCompletion()
{
    // Check if robot has settled
    float vLeft  = drivetrain->getMotorVelocityMMps(WheelSide::LEFT);
    float vRight = drivetrain->getMotorVelocityMMps(WheelSide::RIGHT);
    float vAvg   = (std::fabs(vLeft) + std::fabs(vRight)) / 2.0f;

    float angularVel = sensors->getAngularVelocityDegps();

    // Both linear and angular velocity must be low
    if (vAvg < ROBOT_STOPPING_VELOCITY_MMPS &&
        std::fabs(angularVel) <= ROBOT_TURN_STABILITY_DEGPS)
    {
        stop();
        motionDone = true;
    }
}

// ============================================================
// Position Control Loop (replaces runWheelVelocityControl)
// ============================================================

void Robot::runPositionControl(float dt)
{
    // Step 1: Get encoder deltas (actual movement this cycle)
    float leftDelta  = drivetrain->getMotorDeltaMM(WheelSide::LEFT);
    float rightDelta = drivetrain->getMotorDeltaMM(WheelSide::RIGHT);
    float forwardDelta = (leftDelta + rightDelta) / 2.0f;

    // Step 2: Get IMU delta (actual rotation this cycle)
    float rotationDelta = sensors->getYawDelta();

    // Step 3: Update forward controller (incremental error accumulation)
    float expectedForward = targetForwardVelocityMMps * dt;
    forwardError += (expectedForward - forwardDelta);

    // Step 4: Update rotation controller (incremental error accumulation)
    float expectedRotation = targetAngularVelocityDegps * dt;
    rotationError += (expectedRotation - rotationDelta);

    // Optional: Add steering correction from wall sensors
    // rotationError += calculateSteeringCorrection();

    // Step 5: Calculate PD control outputs
    float forwardOutput  = forwardController.calculateOutput(forwardError, dt);
    float rotationOutput = rotationController.calculateOutput(rotationError, dt);

    // Step 6: Combine for differential drive
    float leftDuty  = forwardOutput - rotationOutput;
    float rightDuty = forwardOutput + rotationOutput;

    // Step 7: Calculate wheel velocities and accelerations for feedforward
    float wheelbaseRadius = WHEEL_BASE_MM / 2.0f;
    float tangentialVel   = targetAngularVelocityDegps * (M_PI / 180.0f) * wheelbaseRadius;

    float leftVel  = targetForwardVelocityMMps - tangentialVel;
    float rightVel = targetForwardVelocityMMps + tangentialVel;

    // Calculate accelerations (for Ka feedforward term)
    static float prevLeftVel  = 0.0f;
    static float prevRightVel = 0.0f;
    float leftAccel  = (leftVel - prevLeftVel) / dt;
    float rightAccel = (rightVel - prevRightVel) / dt;
    prevLeftVel  = leftVel;
    prevRightVel = rightVel;

    // Step 8: Add feedforward (Kv + Ks + Ka)
    float ffLeft  = drivetrain->getFeedforward(WheelSide::LEFT, leftVel, leftAccel);
    float ffRight = drivetrain->getFeedforward(WheelSide::RIGHT, rightVel, rightAccel);

    leftDuty  += ffLeft;
    rightDuty += ffRight;

    // Step 9: Clamp to safe duty cycle limits
    leftDuty  = RobotUtils::clampAbs(leftDuty, ROBOT_MAX_DUTY);
    rightDuty = RobotUtils::clampAbs(rightDuty, ROBOT_MAX_DUTY);

    // Step 10: Apply slew rate limiting to prevent sudden changes
    leftDuty  = applySlew(leftDuty, prevLeftDuty, dt);
    rightDuty = applySlew(rightDuty, prevRightDuty, dt);

    // Step 11: Send duty cycles to motors
    drivetrain->setDuty(leftDuty, rightDuty);

    // Step 12: Update previous errors for derivative calculation
    prevForwardError  = forwardError;
    prevRotationError = rotationError;
}

// ============================================================
// Helper: Get State Name for Logging
// ============================================================

std::string Robot::getStateName() const
{
    switch (state)
    {
        case MotionState::Idle:           return "Idle";
        case MotionState::MovingForward:  return "MovingForward";
        case MotionState::TurningInPlace: return "TurningInPlace";
        case MotionState::SmoothTurning:  return "SmoothTurning";
        case MotionState::Stopping:       return "Stopping";
        default:                          return "Unknown";
    }
}
```

---

## Key Style Matches

1. **Method structure** - Exactly like `driveDistanceMM()`:
   - Set state/mode first
   - Get baselines
   - Start profiles
   - Reset controllers
   - Set targets
   - Set motionDone flag

2. **Big comment headers** - `// ====...====` style

3. **Step-by-step comments** - Numbered steps in complex methods

4. **Variable naming** - `targetForwardVelocityMMps`, `maxDistanceMM`, etc.

5. **Type-safe enums** - `WheelSide::LEFT` instead of strings

6. **Logging style** - Periodic with counter modulo, descriptive messages

7. **Helper methods** - Small, focused (checkForwardCompletion, updateForwardProfile)

8. **Early returns** - In completion checks

9. **Inline comments** - Explain the "why" not the "what"

10. **Whitespace** - Same grouping and spacing patterns
