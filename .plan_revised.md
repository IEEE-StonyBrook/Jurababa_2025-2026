# REVISED IMPLEMENTATION PLAN
## Mazerunner-Core Style Movement Logic Integration into PID_VM Branch

**Date:** 2026-01-03
**Branch:** PID_VM → claude/analyze-maze-robot-logic-kF1LE
**Target:** Replace velocity control with position control + implement clean movement methods

---

## CRITICAL ARCHITECTURAL CHANGE

### What We're Changing

**FROM: Velocity Control Architecture (Current PID_VM)**
```
3 PID Controllers:
├── yawPID (high-level: angle control)
├── leftWheelPID (low-level: left wheel velocity control)
└── rightWheelPID (low-level: right wheel velocity control)

Control Flow:
Position Setpoint → Velocity Setpoint → Wheel Velocity PID → Motor Duty
```

**TO: Position Control Architecture (Mazerunner-Core)**
```
2 PD Controllers:
├── forwardController (position/distance control)
└── rotationController (angle control)

Control Flow:
Position Setpoint → Forward/Rotation PD → Feedforward + Feedback → Motor Duty

Motor Combination:
leftMotor  = forwardOutput - rotationOutput + feedforward
rightMotor = forwardOutput + rotationOutput + feedforward
```

---

## SECTION 1: UNDERSTANDING MAZERUNNER-CORE CONTROL

### 1.1 Incremental Error Accumulation Pattern

**How it works:**
```cpp
// Each control loop cycle:
error += (desired_change - actual_change)

// Where:
// desired_change = targetVelocity * dt
// actual_change = encoderDelta (measured movement)

// PD output:
output = Kp * error + Kd * (error - prevError)
```

**Key insight:** The controller tracks **accumulated position error**, not absolute position. This enables:
- Continuous trajectory correction
- No need for absolute position reference
- Natural integration of velocity commands

### 1.2 Forward Controller

**Purpose:** Control forward linear motion (distance traveled)

**Error accumulation:**
```cpp
float expectedDistance = targetForwardVelocity * LOOP_INTERVAL_S;
float actualDistance = (leftEncoderDelta + rightEncoderDelta) / 2.0f;
forwardError += (expectedDistance - actualDistance);
```

**PD output:**
```cpp
float forwardOutput = FWD_KP * forwardError + FWD_KD * (forwardError - prevForwardError);
```

### 1.3 Rotation Controller

**Purpose:** Control rotation/heading (angle changed)

**Error accumulation:**
```cpp
float expectedRotation = targetAngularVelocity * LOOP_INTERVAL_S;
float actualRotation = imuDeltaAngle; // or (rightDelta - leftDelta) / wheelbase
rotationError += (expectedRotation - actualRotation);

// PLUS external steering correction (wall following, etc.)
rotationError += steeringCorrection;
```

**PD output:**
```cpp
float rotationOutput = ROT_KP * rotationError + ROT_KD * (rotationError - prevRotationError);
```

### 1.4 Motor Combination

```cpp
// Combine forward and rotation
float leftDuty = forwardOutput - rotationOutput;
float rightDuty = forwardOutput + rotationOutput;

// Add feedforward (Kv + Ks + Ka)
leftDuty += feedforwardLeft(targetLeftVelocity, targetLeftAccel);
rightDuty += feedforwardRight(targetRightVelocity, targetRightAccel);

// Apply to motors
leftMotor.setDuty(leftDuty);
rightMotor.setDuty(rightDuty);
```

---

## SECTION 2: MOVEMENT METHODS FROM MAZERUNNER-CORE

### 2.1 Core Movement Methods

| Method | Purpose | Parameters |
|--------|---------|------------|
| `move(distance, maxVel, finalVel, accel)` | Move forward with trapezoidal profile | distance, max velocity, final velocity, acceleration |
| `moveAhead()` | Continue forward to next cell | None (uses defaults) |
| `turnInPlace90R()` | Rotate right 90° on center axis | None |
| `turnInPlace90L()` | Rotate left 90° on center axis | None |
| `turnInPlace180()` | Rotate 180° (alternates direction) | None |
| `turnToFace(heading)` | Turn to specific heading (N/E/S/W) | Target heading |
| `turnSmooth(turnType)` | Coordinated turn while moving | Turn identifier |
| `stopAtCenter()` | Stop at cell center with wall feedback | None |
| `backToWall()` | Reverse until hitting wall, recalibrate | None |
| `arcTurn(radius, angle)` | Follow arc trajectory | Radius, angle |

### 2.2 Movement Method Implementation Strategy

**Group 1: Basic Motion (Implement First)**
1. `moveDistance(float mm, float maxVel)` - Forward with profiling
2. `stopAtCenter()` - Stop with position hold
3. `turnInPlace(float degrees)` - Generic in-place turn

**Group 2: Cell Navigation (Build on Basic)**
4. `moveToNextCell()` - Move exactly one cell (180mm)
5. `turnLeft90()` - Wrapper for turnInPlace(-90)
6. `turnRight90()` - Wrapper for turnInPlace(90)
7. `turnAround()` - Wrapper for turnInPlace(180)

**Group 3: Advanced Motion**
8. `smoothTurn(float degrees, float radius)` - Coordinated arc turn
9. `backToWall(float maxDistance)` - Reverse calibration
10. `centerWithWalls()` - Use ToF feedback to center

---

## SECTION 3: NEW ARCHITECTURE DESIGN

### 3.1 New Class Structure

```
Robot (REFACTORED)
├── MotionProfile forwardProfile_      (NEW - trapezoidal profiles)
├── MotionProfile rotationProfile_     (NEW - angular profiles)
├── PIDController forwardController_   (NEW - replaces leftWheelPID + rightWheelPID)
├── PIDController rotationController_  (ENHANCED - replaces yawPID)
└── Movement methods                   (NEW - clean API)
    ├── moveDistance()
    ├── turnInPlace()
    ├── smoothTurn()
    ├── stopAtCenter()
    └── backToWall()
```

### 3.2 File Changes Overview

**Files to CREATE:**
```
Include/Common/MotionProfile.h
src/Common/MotionProfile.cpp
```

**Files to HEAVILY MODIFY:**
```
Include/Platform/Pico/Robot/Robot.h     - Replace controllers, add movement methods
src/Platform/Pico/Robot/Robot.cpp       - Rewrite control loop, add methods
Include/Platform/Pico/Robot/Drivetrain.h - Add Ka feedforward
src/Platform/Pico/Robot/Drivetrain.cpp  - Implement Ka term
Include/Platform/Pico/Config.h          - Add new constants
```

**Classes to DELETE from Robot:**
```
- PIDController leftWheelPID;   // DELETE
- PIDController rightWheelPID;  // DELETE
- Mode-based enum (replace with cleaner state machine)
```

**Classes to ADD to Robot:**
```
+ MotionProfile forwardProfile_;
+ MotionProfile rotationProfile_;
+ PIDController forwardController_;  // Position control, not velocity!
+ PIDController rotationController_; // Angle control
+ float forwardError_;               // Incremental error accumulation
+ float rotationError_;
+ float prevForwardError_;
+ float prevRotationError_;
```

---

## SECTION 4: DETAILED IMPLEMENTATION PLAN

### Phase 1: Create MotionProfile Class (Same as before)

**File:** `Include/Common/MotionProfile.h`

```cpp
class MotionProfile
{
public:
    enum class State { Idle, Accelerating, Cruising, Decelerating, Finished };

    void start(float targetDistance, float maxVelocity, float acceleration, float initialPosition);
    void update(float currentPosition, float dt);

    float getTargetVelocity() const;
    float getTargetAcceleration() const;
    float getRemainingDistance() const;
    bool isFinished() const;
    State getState() const;
    void reset();

private:
    State state_;
    float targetDistance_;
    float maxVelocity_;
    float acceleration_;
    float initialPosition_;
    float currentVelocity_;
    float currentAcceleration_;

    // Pre-calculated profile parameters
    float accelDistance_;
    float decelDistance_;
    float cruiseDistance_;
    float cruiseVelocity_;
};
```

**Key changes from original plan:** Same implementation, used for both forward and rotation.

---

### Phase 2: Refactor Robot Class Controllers

**File:** `Include/Platform/Pico/Robot/Robot.h`

**REMOVE these members:**
```cpp
// DELETE - no more velocity control!
PIDController leftWheelPID;
PIDController rightWheelPID;

// DELETE - old mode enum
enum class Mode { Idle, DriveStraight, DriveDistance, TurnInPlace, ArcTurn };
Mode mode;
```

**ADD these members:**
```cpp
#include "Common/MotionProfile.h"

// Motion profiles
MotionProfile forwardProfile_;
MotionProfile rotationProfile_;

// Position-based PD controllers
PIDController forwardController_;   // Controls forward distance (PD only: Ki=0)
PIDController rotationController_;  // Controls rotation angle (PD only: Ki=0)

// Incremental error tracking (mazerunner pattern)
float forwardError_;
float rotationError_;
float prevForwardError_;
float prevRotationError_;

// Target tracking for feedforward
float targetForwardVelocity_;
float targetAngularVelocity_;
float targetForwardAcceleration_;

// State tracking
enum class MotionState {
    Idle,
    MovingForward,
    TurningInPlace,
    SmoothTurning,
    Stopping
};
MotionState state_;
```

**ADD movement method declarations:**
```cpp
public:
    // === Basic Motion Commands ===
    void moveDistance(float distanceMM, float maxVelocityMMps, float acceleration);
    void turnInPlace(float degrees, float maxVelocityDegps, float acceleration);
    void stopAtCenter();
    void stop();

    // === Cell Navigation (Convenience Wrappers) ===
    void moveToNextCell();     // Move 180mm
    void turnLeft90();         // Turn -90°
    void turnRight90();        // Turn +90°
    void turnAround();         // Turn 180°

    // === Advanced Motion ===
    void smoothTurn(float degrees, float radiusMM);
    void backToWall(float maxDistanceMM);
    void centerWithWalls();

    // === Status Queries ===
    bool isMotionComplete() const;
    float getRemainingDistance() const;
    float getRemainingAngle() const;

private:
    // === Control Loop (called at 100Hz) ===
    void updateControl(float dt);
    void updateForwardProfile(float dt);
    void updateRotationProfile(float dt);
    void runPositionControl(float dt);  // NEW: replaces runWheelVelocityControl
```

---

### Phase 3: Implement Position Control Loop

**File:** `src/Platform/Pico/Robot/Robot.cpp`

**Key method: `runPositionControl()` - Replaces `runWheelVelocityControl()`**

```cpp
void Robot::runPositionControl(float dt)
{
    // Get encoder deltas (actual movement this cycle)
    float leftDelta = drivetrain->getMotorDeltaMM(WheelSide::LEFT);
    float rightDelta = drivetrain->getMotorDeltaMM(WheelSide::RIGHT);
    float forwardDelta = (leftDelta + rightDelta) / 2.0f;

    // Get IMU delta (actual rotation this cycle)
    float rotationDelta = sensors->getYawDelta(); // Need to implement this!

    // FORWARD CONTROLLER - Incremental error accumulation
    float expectedForward = targetForwardVelocity_ * dt;
    forwardError_ += (expectedForward - forwardDelta);

    // ROTATION CONTROLLER - Incremental error accumulation
    float expectedRotation = targetAngularVelocity_ * dt;
    rotationError_ += (expectedRotation - rotationDelta);

    // Add steering correction (from wall following, etc.)
    // rotationError_ += steeringCorrection;  // Optional, implement later

    // PD control outputs
    float forwardOutput = forwardController_.calculateOutput(forwardError_, dt);
    float rotationOutput = rotationController_.calculateOutput(rotationError_, dt);

    // Combine: differential drive
    float leftDuty = forwardOutput - rotationOutput;
    float rightDuty = forwardOutput + rotationOutput;

    // Calculate wheel velocities for feedforward
    float wheelbaseRadius = WHEEL_BASE_MM / 2.0f;
    float tangentialVel = targetAngularVelocity_ * (M_PI / 180.0f) * wheelbaseRadius;
    float leftVel = targetForwardVelocity_ - tangentialVel;
    float rightVel = targetForwardVelocity_ + tangentialVel;

    // Calculate wheel accelerations for feedforward
    static float prevLeftVel = 0.0f;
    static float prevRightVel = 0.0f;
    float leftAccel = (leftVel - prevLeftVel) / dt;
    float rightAccel = (rightVel - prevRightVel) / dt;
    prevLeftVel = leftVel;
    prevRightVel = rightVel;

    // Add feedforward (Kv + Ks + Ka)
    float ffLeft = drivetrain->getFeedforward(WheelSide::LEFT, leftVel, leftAccel);
    float ffRight = drivetrain->getFeedforward(WheelSide::RIGHT, rightVel, rightAccel);

    leftDuty += ffLeft;
    rightDuty += ffRight;

    // Clamp and apply
    leftDuty = RobotUtils::clampAbs(leftDuty, ROBOT_MAX_DUTY);
    rightDuty = RobotUtils::clampAbs(rightDuty, ROBOT_MAX_DUTY);

    // Apply slew rate limiting
    leftDuty = applySlew(leftDuty, prevLeftDuty_, dt);
    rightDuty = applySlew(rightDuty, prevRightDuty_, dt);

    prevLeftDuty_ = leftDuty;
    prevRightDuty_ = rightDuty;

    // Set motor duties
    drivetrain->setDuty(leftDuty, rightDuty);

    // Update previous errors for derivative
    prevForwardError_ = forwardError_;
    prevRotationError_ = rotationError_;
}
```

---

### Phase 4: Implement Movement Methods

#### 4.1 moveDistance() - Forward motion with profiling

```cpp
void Robot::moveDistance(float distanceMM, float maxVelocityMMps, float accelMMps2)
{
    // Get current position
    float currentPos = (drivetrain->getMotorDistanceMM(WheelSide::LEFT) +
                       drivetrain->getMotorDistanceMM(WheelSide::RIGHT)) / 2.0f;

    // Start forward profile
    forwardProfile_.start(distanceMM, maxVelocityMMps, accelMMps2, currentPos);

    // Reset rotation profile (maintain current heading)
    rotationProfile_.reset();

    // Reset controllers
    forwardController_.reset();
    rotationController_.reset();
    forwardError_ = 0.0f;
    rotationError_ = 0.0f;
    prevForwardError_ = 0.0f;
    prevRotationError_ = 0.0f;

    // Set target velocities
    targetForwardVelocity_ = 0.0f;  // Will be updated by profile
    targetAngularVelocity_ = 0.0f;  // Maintain heading

    state_ = MotionState::MovingForward;
}
```

#### 4.2 turnInPlace() - In-place rotation

```cpp
void Robot::turnInPlace(float degrees, float maxVelocityDegps, float accelDegps2)
{
    // Get current angle
    float currentAngle = sensors->getYaw();

    // Start rotation profile
    rotationProfile_.start(degrees, maxVelocityDegps, accelDegps2, currentAngle);

    // Reset forward profile (no forward motion)
    forwardProfile_.reset();

    // Reset controllers
    forwardController_.reset();
    rotationController_.reset();
    forwardError_ = 0.0f;
    rotationError_ = 0.0f;
    prevForwardError_ = 0.0f;
    prevRotationError_ = 0.0f;

    // Set target velocities
    targetForwardVelocity_ = 0.0f;      // No forward motion
    targetAngularVelocity_ = 0.0f;      // Will be updated by profile

    state_ = MotionState::TurningInPlace;
}
```

#### 4.3 Convenience wrappers

```cpp
void Robot::moveToNextCell()
{
    moveDistance(180.0f, ROBOT_MAX_SEARCH_SPEED_MMPS, ROBOT_BASE_ACCEL_MMPS2);
}

void Robot::turnLeft90()
{
    turnInPlace(-90.0f, ROBOT_MAX_TURN_SPEED_DEGPS, ROBOT_BASE_ANGULAR_ACCEL_DEGPS2);
}

void Robot::turnRight90()
{
    turnInPlace(90.0f, ROBOT_MAX_TURN_SPEED_DEGPS, ROBOT_BASE_ANGULAR_ACCEL_DEGPS2);
}

void Robot::turnAround()
{
    // Alternate direction like mazerunner-core
    static bool turnRight = true;
    float angle = turnRight ? 180.0f : -180.0f;
    turnRight = !turnRight;
    turnInPlace(angle, ROBOT_MAX_TURN_SPEED_DEGPS, ROBOT_BASE_ANGULAR_ACCEL_DEGPS2);
}
```

#### 4.4 stopAtCenter() - Stop with position hold

```cpp
void Robot::stopAtCenter()
{
    // Reset profiles
    forwardProfile_.reset();
    rotationProfile_.reset();

    // Set zero velocity targets
    targetForwardVelocity_ = 0.0f;
    targetAngularVelocity_ = 0.0f;

    // Keep controllers active for position hold
    // Errors will decay as robot settles

    state_ = MotionState::Stopping;
}

void Robot::stop()
{
    stopAtCenter();

    // Also reset errors for full stop
    forwardError_ = 0.0f;
    rotationError_ = 0.0f;
    prevForwardError_ = 0.0f;
    prevRotationError_ = 0.0f;

    // Stop motors
    drivetrain->setDuty(0.0f, 0.0f);

    state_ = MotionState::Idle;
}
```

#### 4.5 backToWall() - Reverse calibration

```cpp
void Robot::backToWall(float maxDistanceMM)
{
    // Move backward slowly until wall detected or max distance reached
    // This uses front ToF sensor to detect when we hit the wall

    moveDistance(-maxDistanceMM, ROBOT_BACKUP_SPEED_MMPS, ROBOT_BASE_ACCEL_MMPS2);

    // In updateControl(), check ToF sensor:
    // if (sensors->getFrontDistanceMM() < WALL_CONTACT_THRESHOLD_MM) {
    //     stop();
    //     // Reset odometry: we know we're BACK_WALL_TO_CENTER mm from center
    //     drivetrain->resetPosition();
    // }
}
```

#### 4.6 smoothTurn() - Coordinated arc turn

```cpp
void Robot::smoothTurn(float degrees, float radiusMM)
{
    // Calculate arc parameters
    float arcLength = std::abs(degrees) * (M_PI / 180.0f) * radiusMM;

    // Start both profiles simultaneously
    float currentPos = (drivetrain->getMotorDistanceMM(WheelSide::LEFT) +
                       drivetrain->getMotorDistanceMM(WheelSide::RIGHT)) / 2.0f;
    float currentAngle = sensors->getYaw();

    forwardProfile_.start(arcLength, ROBOT_MAX_SMOOTH_TURN_SPEED_MMPS,
                         ROBOT_BASE_ACCEL_MMPS2, currentPos);
    rotationProfile_.start(degrees, ROBOT_MAX_TURN_SPEED_DEGPS,
                          ROBOT_BASE_ANGULAR_ACCEL_DEGPS2, currentAngle);

    // Reset controllers
    forwardController_.reset();
    rotationController_.reset();
    forwardError_ = 0.0f;
    rotationError_ = 0.0f;

    state_ = MotionState::SmoothTurning;
}
```

---

### Phase 5: Update Control Loop

**File:** `src/Platform/Pico/Robot/Robot.cpp`

**Main update method (called at 100Hz):**

```cpp
void Robot::updateControl(float dt)
{
    // Update motion profiles
    if (state_ == MotionState::MovingForward || state_ == MotionState::SmoothTurning) {
        updateForwardProfile(dt);
    }

    if (state_ == MotionState::TurningInPlace || state_ == MotionState::SmoothTurning) {
        updateRotationProfile(dt);
    }

    // Run position control loop
    runPositionControl(dt);

    // Check for motion completion
    if (state_ == MotionState::MovingForward && forwardProfile_.isFinished()) {
        stopAtCenter();
    }

    if (state_ == MotionState::TurningInPlace && rotationProfile_.isFinished()) {
        stopAtCenter();
    }

    if (state_ == MotionState::SmoothTurning &&
        forwardProfile_.isFinished() && rotationProfile_.isFinished()) {
        stopAtCenter();
    }
}

void Robot::updateForwardProfile(float dt)
{
    float currentPos = (drivetrain->getMotorDistanceMM(WheelSide::LEFT) +
                       drivetrain->getMotorDistanceMM(WheelSide::RIGHT)) / 2.0f;

    forwardProfile_.update(currentPos, dt);

    // Update target velocity and acceleration for control loop
    targetForwardVelocity_ = forwardProfile_.getTargetVelocity();
    targetForwardAcceleration_ = forwardProfile_.getTargetAcceleration();
}

void Robot::updateRotationProfile(float dt)
{
    float currentAngle = sensors->getYaw();

    rotationProfile_.update(currentAngle, dt);

    // Update target angular velocity
    targetAngularVelocity_ = rotationProfile_.getTargetVelocity();
}
```

---

### Phase 6: Add Drivetrain Enhancements

**File:** `src/Platform/Pico/Robot/Drivetrain.cpp`

**Add Ka acceleration feedforward (same as original plan):**

```cpp
float Drivetrain::getFeedforward(WheelSide side, float velocity, float accel)
{
    if (std::fabs(velocity) < DRIVETRAIN_FF_DEADZONE_MMPS)
        return 0.0f;

    bool is_left = (side == WheelSide::LEFT);

    float kv, ks, ka;
    if (velocity > 0.0f) {
        kv = is_left ? FORWARD_KVL : FORWARD_KVR;
        ks = is_left ? FORWARD_KSL : FORWARD_KSR;
        ka = is_left ? FORWARD_KAL : FORWARD_KAR;
        return kv * velocity + ks + ka * accel;
    } else {
        kv = is_left ? REVERSE_KVL : REVERSE_KVR;
        ks = is_left ? REVERSE_KSL : REVERSE_KSR;
        ka = is_left ? REVERSE_KAL : REVERSE_KAR;
        return kv * velocity - ks + ka * accel;
    }
}
```

**Add encoder delta tracking:**

```cpp
// Add to Drivetrain class
private:
    float lastLeftPosition_;
    float lastRightPosition_;

public:
    float getMotorDeltaMM(WheelSide side) {
        float currentPos = getMotorDistanceMM(side);
        float& lastPos = (side == WheelSide::LEFT) ? lastLeftPosition_ : lastRightPosition_;
        float delta = currentPos - lastPos;
        lastPos = currentPos;
        return delta;
    }
```

**Add to Sensors class:**

```cpp
// Need IMU delta tracking
float Sensors::getYawDelta() {
    float currentYaw = getYaw();
    float delta = RobotUtils::wrapAngle180(currentYaw - lastYaw_);
    lastYaw_ = currentYaw;
    return delta;
}
```

---

### Phase 7: Configuration Updates

**File:** `Include/Platform/Pico/Config.h`

**Add new constants:**

```cpp
// ================= Motion Profile Constants ================= //
#define PROFILE_MAX_FORWARD_VELOCITY_MMPS   500.0f
#define PROFILE_MAX_FORWARD_ACCEL_MMPS2     1500.0f
#define PROFILE_MAX_ANGULAR_VELOCITY_DEGPS  360.0f
#define PROFILE_MAX_ANGULAR_ACCEL_DEGPS2    720.0f

#define PROFILE_POSITION_TOLERANCE_MM       2.0f
#define PROFILE_VELOCITY_TOLERANCE_MMPS     30.0f
#define PROFILE_ANGLE_TOLERANCE_DEG         2.0f

// ================= Robot Speed Presets ================= //
#define ROBOT_MAX_SEARCH_SPEED_MMPS         300.0f   // Search mode
#define ROBOT_MAX_SPEED_RUN_MMPS            800.0f   // Speed run
#define ROBOT_MAX_TURN_SPEED_DEGPS          360.0f   // Turn speed
#define ROBOT_BACKUP_SPEED_MMPS             100.0f   // Backing up

// ================= Position Controller Gains ================= //
// Forward PD controller (position control)
#define FWD_KP  0.05f  // Proportional gain for forward position error
#define FWD_KD  0.6f   // Derivative gain for forward position error
#define FWD_KI  0.0f   // Integral disabled for PD control

// Rotation PD controller (angle control)
#define ROT_KP  0.15f  // Proportional gain for rotation error
#define ROT_KD  0.5f   // Derivative gain for rotation error
#define ROT_KI  0.0f   // Integral disabled for PD control

// ================= Acceleration Feedforward ================= //
#define FORWARD_KAL  0.0f  // Left motor acceleration gain (tune later)
#define FORWARD_KAR  0.0f  // Right motor acceleration gain
#define REVERSE_KAL  0.0f
#define REVERSE_KAR  0.0f

// ================= Wall Detection ================= //
#define WALL_CONTACT_THRESHOLD_MM  30.0f   // Distance indicating wall contact
#define BACK_WALL_TO_CENTER_MM     90.0f   // Distance from back wall to cell center
```

---

## SECTION 5: IMPLEMENTATION STEPS (EXECUTION ORDER)

### Step 1: Create MotionProfile Class (2 hours)
1. Create `Include/Common/MotionProfile.h`
2. Create `src/Common/MotionProfile.cpp`
3. Implement trapezoidal profile algorithm
4. Add to CMakeLists.txt
5. Write basic unit test

### Step 2: Refactor Robot Class Structure (1 hour)
1. **REMOVE** leftWheelPID, rightWheelPID from Robot.h
2. **ADD** forwardController_, rotationController_
3. **ADD** forwardProfile_, rotationProfile_
4. **ADD** error tracking members
5. **ADD** movement method declarations

### Step 3: Implement Position Control Loop (2 hours)
1. Implement `runPositionControl()` with incremental error pattern
2. Add encoder delta tracking to Drivetrain
3. Add IMU delta tracking to Sensors
4. Wire up control loop in `updateControl()`

### Step 4: Add Acceleration Feedforward (30 min)
1. Update `Drivetrain::getFeedforward()` signature
2. Add Ka term implementation
3. Add Ka constants to Config.h

### Step 5: Implement Basic Movement Methods (3 hours)
1. Implement `moveDistance()`
2. Implement `turnInPlace()`
3. Implement `stopAtCenter()` and `stop()`
4. Test each method individually

### Step 6: Implement Convenience Wrappers (1 hour)
1. Implement `moveToNextCell()`
2. Implement `turnLeft90()`, `turnRight90()`, `turnAround()`
3. Test cell navigation

### Step 7: Implement Advanced Methods (2-3 hours)
1. Implement `smoothTurn()`
2. Implement `backToWall()`
3. Implement `centerWithWalls()` (uses ToF feedback)

### Step 8: Testing and Tuning (4-8 hours)
1. Tune FWD_KP, FWD_KD for forward control
2. Tune ROT_KP, ROT_KD for rotation control
3. Tune Ka feedforward values
4. Test all movement methods
5. Profile motion quality

**Total Estimated Time: 15-20 hours**

---

## SECTION 6: WHAT TO DELETE VS KEEP VS ADD

### ❌ DELETE

**From Robot.h/cpp:**
- `PIDController leftWheelPID;`
- `PIDController rightWheelPID;`
- `Mode enum` (Idle, DriveStraight, DriveDistance, etc.)
- `runWheelVelocityControl()` method
- `commandBaseAndYaw()` method
- `calculateTargetVelocityForDistance()` method
- `rampToward()` method
- All mode-specific handlers (handleDriveStraightMode, etc.)

### ✅ KEEP

**Existing good code:**
- `PIDController class` (reuse for forwardController, rotationController)
- `Drivetrain class` (enhance with Ka)
- `RobotUtils` utilities
- `Sensors, Motor, Encoder, IMU, ToF` classes
- `Config.h` structure
- Multicore architecture

### ➕ ADD

**New to Robot:**
- `MotionProfile forwardProfile_`
- `MotionProfile rotationProfile_`
- `PIDController forwardController_` (position control)
- `PIDController rotationController_` (angle control)
- Incremental error tracking members
- All movement methods (moveDistance, turnInPlace, etc.)
- New MotionState enum
- `runPositionControl()` method
- Profile update methods

**New files:**
- `MotionProfile.h/cpp`

---

## SECTION 7: API COMPARISON

### Old API (PID_VM - Velocity Control)

```cpp
// Old way - complex, mode-based
robot.driveDistanceMM(180.0f, 300.0f);
while (!robot.isMotionDone()) { /* wait */ }

robot.turnToYawDeg(90.0f);
while (!robot.isMotionDone()) { /* wait */ }
```

### New API (Mazerunner Style - Position Control)

```cpp
// New way - clean, direct
robot.moveToNextCell();
while (!robot.isMotionComplete()) { /* wait */ }

robot.turnRight90();
while (!robot.isMotionComplete()) { /* wait */ }

// Or even cleaner:
robot.moveDistance(180.0f, 300.0f, 1500.0f);  // distance, velocity, accel
robot.turnInPlace(90.0f, 360.0f, 720.0f);     // angle, velocity, accel
```

**Advantages:**
- Simpler, more intuitive API
- Direct control over motion parameters
- Consistent naming (move*, turn*)
- Easier to understand and debug
- Matches physical motion more closely

---

## SECTION 8: TESTING STRATEGY

### Unit Tests

1. **MotionProfile class:**
   - Short move (can't reach max velocity)
   - Long move (full trapezoid)
   - Verify state transitions
   - Check velocity/acceleration outputs

2. **Controller integration:**
   - Forward controller response
   - Rotation controller response
   - Combined output verification

### Integration Tests

1. **Basic motion:**
   - Move 180mm (one cell)
   - Turn 90° in place
   - Verify accuracy ±2mm, ±2°

2. **Cell navigation:**
   - moveToNextCell() × 3
   - turnLeft90()
   - moveToNextCell() × 2
   - Verify position accuracy

3. **Smooth turns:**
   - 90° arc at 200mm radius
   - Verify smooth trajectory

4. **Back to wall:**
   - Reverse calibration
   - Verify position reset

### Hardware Tests

1. Straight line accuracy (5 cells)
2. Turn accuracy (4× 90° = 360°, should return to start)
3. Speed response (acceleration profiles)
4. Wall following integration

---

## SECTION 9: MIGRATION GUIDE

### For Existing Code Using Robot

**Old code:**
```cpp
robot->driveDistanceMM(540.0f, 300.0f);
```

**New code:**
```cpp
robot->moveDistance(540.0f, 300.0f, ROBOT_BASE_ACCEL_MMPS2);
```

**Old code:**
```cpp
robot->turnToYawDeg(90.0f);
```

**New code:**
```cpp
robot->turnInPlace(90.0f, ROBOT_MAX_TURN_SPEED_DEGPS, ROBOT_BASE_ANGULAR_ACCEL_DEGPS2);
// Or use convenience wrapper:
robot->turnRight90();
```

### API Compatibility Layer (Optional)

If you want to maintain backward compatibility temporarily:

```cpp
// Deprecated wrappers - remove after migration
void Robot::driveDistanceMM(float mm, float vel) {
    LOG_WARN("driveDistanceMM deprecated, use moveDistance()");
    moveDistance(mm, vel, ROBOT_BASE_ACCEL_MMPS2);
}

void Robot::turnToYawDeg(float yaw) {
    LOG_WARN("turnToYawDeg deprecated, use turnInPlace()");
    float currentYaw = sensors->getYaw();
    float deltaDeg = RobotUtils::wrapAngle180(yaw - currentYaw);
    turnInPlace(deltaDeg, ROBOT_MAX_TURN_SPEED_DEGPS, ROBOT_BASE_ANGULAR_ACCEL_DEGPS2);
}
```

---

## SECTION 10: TUNING GUIDE

### Forward Controller Tuning

**Start values:**
- FWD_KP = 0.05
- FWD_KD = 0.6
- FWD_KI = 0.0 (disabled)

**Tuning process:**
1. Set Kd = 0, tune Kp for desired response
2. If oscillating, reduce Kp
3. Add Kd to dampen oscillations
4. Test with different distances (180mm, 540mm, 900mm)

### Rotation Controller Tuning

**Start values:**
- ROT_KP = 0.15
- ROT_KD = 0.5
- ROT_KI = 0.0 (disabled)

**Tuning process:**
1. Test 90° turns
2. Adjust Kp for settling time
3. Add Kd to reduce overshoot
4. Verify 45°, 90°, 180° all work well

### Acceleration Feedforward Tuning

**Start values:**
- KAL, KAR = 0.0 (disabled)

**Tuning process:**
1. Log actual vs target velocity during acceleration
2. If lagging during accel, increase Ka
3. If overshooting, decrease Ka
4. Typical values: 0.0001 to 0.001

---

## CONCLUSION

This revised plan implements a **fundamental architectural change** from velocity control to position control, matching mazerunner-core's proven approach. The key changes:

1. **Replace 3 PIDs with 2 PDs** - forwardController (position) + rotationController (angle)
2. **Incremental error accumulation** - mazerunner pattern for smooth control
3. **Clean movement API** - moveDistance(), turnInPlace(), moveToNextCell(), etc.
4. **Trapezoidal profiling** - smooth acceleration/deceleration
5. **3-term feedforward** - Kv + Ks + Ka for better tracking

**Implementation time: 15-20 hours**

**Benefits:**
- Simpler, more intuitive control
- Better position accuracy
- Cleaner API for navigation
- Proven architecture from mazerunner-core
- Easier to understand and debug

**Next steps:** Proceed with Phase 1 (MotionProfile class) and work through systematically.
